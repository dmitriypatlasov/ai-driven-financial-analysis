{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "99d8f026-5bce-478b-ae20-eca79cd2337b",
   "metadata": {},
   "outputs": [],
   "source": [
    "import pandas as pd\n",
    "import numpy as np\n",
    "from scipy.interpolate import RectBivariateSpline\n",
    "from scipy.optimize import minimize\n",
    "from scipy.stats import norm, multivariate_normal, gaussian_kde, multivariate_t\n",
    "import yfinance as yf\n",
    "from datetime import timedelta, datetime\n",
    "from datetime import datetime as dt\n",
    "from datetime import date as dt_date\n",
    "from scipy.linalg import eig, solve\n",
    "import warnings\n",
    "warnings.filterwarnings(\"ignore\")\n",
    "import plotly.graph_objects as go\n",
    "import matplotlib.pyplot as plt\n",
    "from scipy.stats import skew, kurtosis\n",
    "import tensorflow as tf\n",
    "import joblib\n",
    "\n",
    "def get_option_data(instrument):\n",
    "    \"\"\"\n",
    "    Получает данные по опционам для заданного тикера и возвращает DataFrame.\n",
    "\n",
    "    Параметры:\n",
    "    ----------\n",
    "    instrument : str\n",
    "        Тикер актива (например, 'SPY').\n",
    "\n",
    "    Возвращает:\n",
    "    -----------\n",
    "    pd.DataFrame\n",
    "        DataFrame с данными по опционам, содержащий столбцы: STRIKE, C_IV, expiration_date, Tenor.\n",
    "    \"\"\"\n",
    "    \n",
    "    # Получаем данные по тикеру\n",
    "    options_data = yf.Ticker(instrument)\n",
    "\n",
    "    # Получаем все даты экспирации\n",
    "    expiration_dates = options_data.options\n",
    "\n",
    "    # Текущая дата для расчета срока до погашения\n",
    "    today = pd.to_datetime(dt.today())\n",
    "\n",
    "    # Собираем данные по опционам и рассчитываем Tenor\n",
    "    data = pd.concat(\n",
    "        [\n",
    "            pd.DataFrame({\n",
    "                'STRIKE': options_data.option_chain(exp_date).calls['strike'],\n",
    "                'C_IV': options_data.option_chain(exp_date).calls['impliedVolatility'],\n",
    "                'expiration_date': pd.to_datetime(exp_date),\n",
    "            }).assign(Tenor=(pd.to_datetime(exp_date) - today).days / 365)\n",
    "            for exp_date in expiration_dates\n",
    "        ],\n",
    "        ignore_index=True\n",
    "    )\n",
    "\n",
    "    # Фильтруем данные\n",
    "    data = data[(data['Tenor'] <= 1) & (data['Tenor'] >= 0)]\n",
    "\n",
    "    return data\n",
    "\n",
    "def black_scholes_call(S: float, K: float, r: float, T: float, sigma: float) -> float:\n",
    "    \"\"\"\n",
    "    Вычисляет цену колл-опциона по формуле Блэка-Шоулза.\n",
    "\n",
    "    Параметры:\n",
    "    S (float): Текущая цена базового актива (например, акции).\n",
    "    K (float): Исполнительная цена (страйк) опциона.\n",
    "    r (float): Безрисковая процентная ставка (в виде десятичной дроби).\n",
    "    T (float): Время до истечения опциона (в годах).\n",
    "    sigma (float): Вмененная волатильность базового актива (в виде десятичной дроби).\n",
    "\n",
    "    Возвращает:\n",
    "    float: Цена колл-опциона.\n",
    "    \"\"\"\n",
    "    \n",
    "    # Вычисление d1 и d2\n",
    "    d1 = (np.log(S / K) + (r + 0.5 * sigma**2) * T) / (sigma * np.sqrt(T))\n",
    "    d2 = d1 - sigma * np.sqrt(T)\n",
    "    \n",
    "    # Вычисление цены колл-опциона\n",
    "    call_price = S * norm.cdf(d1) - K * np.exp(-r * T) * norm.cdf(d2)\n",
    "    \n",
    "    return call_price\n",
    "\n",
    "def calculate_p_matrix(state_prices):\n",
    "    \"\"\"\n",
    "    Рассчитывает матрицу вероятностей перехода p_matrix для заданных значений state_prices.\n",
    "\n",
    "    Параметры:\n",
    "    state_prices (pd.DataFrame): DataFrame с ценами состояний, где строки и столбцы соответствуют состояниям.\n",
    "\n",
    "    Возвращает:\n",
    "    pd.DataFrame: Матрица вероятностей перехода p_matrix, нормированная и подготовленная.\n",
    "    \"\"\"\n",
    "    state_prices_values = state_prices.values\n",
    "    size = len(state_prices)\n",
    "\n",
    "    def error_function(p_values):\n",
    "        \"\"\"Целевая функция для минимизации.\"\"\"\n",
    "        p_matrix = np.array(p_values).reshape((size, size))\n",
    "\n",
    "        total_error = 0\n",
    "        for i in range(size):\n",
    "            row_error = 0\n",
    "            for j in range(1, size + 1):\n",
    "                state_prices_hat_ij = np.dot(state_prices_values[i, 1:], p_matrix[:, i])\n",
    "                row_error += (state_prices_hat_ij - state_prices_values[i][j - 1]) ** 2\n",
    "            total_error += row_error\n",
    "        return total_error\n",
    "\n",
    "    def create_ordering_constraints(size):\n",
    "        \"\"\"Создает список ограничений для матрицы вероятностей перехода размером size x size.\"\"\"\n",
    "        ordering_constraints = []\n",
    "\n",
    "        for i in range(size):\n",
    "            for j in range(size):\n",
    "                if j < i:\n",
    "                    # Условие для элементов до диагонали: возрастание\n",
    "                    ordering_constraints.append({\n",
    "                        'type': 'ineq',\n",
    "                        'fun': lambda p_values, i=i, j=j: p_values[size * i + j] - p_values[size * i + j - 1]\n",
    "                    })\n",
    "                elif j > i:\n",
    "                    # Условие для элементов после диагонали: убывание\n",
    "                    ordering_constraints.append({\n",
    "                        'type': 'ineq',\n",
    "                        'fun': lambda p_values, i=i, j=j: p_values[size * i + j] - p_values[size * i + j + 1]\n",
    "                    })\n",
    "\n",
    "            # Ограничение для строгого максимального значения на диагонали\n",
    "            max_index = size * i + i\n",
    "            row_indices = [size * i + k for k in range(size) if k != i]\n",
    "            ordering_constraints.append({\n",
    "                'type': 'eq',\n",
    "                'fun': lambda p_values, max_index=max_index, row_indices=row_indices:\n",
    "                    p_values[max_index] - max([p_values[idx] for idx in row_indices]) - 1e-8\n",
    "            })\n",
    "\n",
    "        return ordering_constraints\n",
    "\n",
    "    # Задаем ограничения на суммы строк\n",
    "    row_sum_constraints = {\n",
    "        'type': 'eq',\n",
    "        'fun': lambda p_values: np.array([p_values[i:i + size].sum() - 1 for i in range(0, size**2, size)])\n",
    "    }\n",
    "\n",
    "    # Создаем начальное предположение и ограничения\n",
    "    initial_guess = np.full((size, size), 0).flatten()\n",
    "    constraints = [row_sum_constraints] + create_ordering_constraints(size)\n",
    "    bounds = [(0, 1) for _ in range(size * size)]\n",
    "\n",
    "    # Запускаем оптимизацию\n",
    "    result = minimize(error_function, initial_guess, bounds=bounds, constraints=constraints, method='Nelder-Mead')\n",
    "\n",
    "    # Преобразуем результат в матрицу и корректируем центральную строку\n",
    "    p_matrix = result.x.reshape((size, size))\n",
    "    central_column_values = [row[0] for row in state_prices_values]\n",
    "    central_row_index = size // 2\n",
    "    p_matrix[central_row_index] = central_column_values\n",
    "\n",
    "    # Создаем DataFrame и нормируем значения\n",
    "    p_matrix = pd.DataFrame(p_matrix, index=state_prices.index, columns=state_prices.index)\n",
    "    p_matrix[p_matrix < 0] = 0\n",
    "    p_matrix = p_matrix.div(p_matrix.sum(axis=1), axis=0)\n",
    "\n",
    "    return p_matrix\n",
    "\n",
    "def calculate_f_matrix(p_matrix, state_prices):\n",
    "    \"\"\"\n",
    "    Реализация Теоремы восстановления для вычисления матрицы натуральных вероятностей F.\n",
    "    \n",
    "    Параметры:\n",
    "    - P: numpy.ndarray, матрица риск-нейтральных вероятностей (m x m), строки суммируются к 1.\n",
    "    \n",
    "    Возвращает:\n",
    "    - F: numpy.ndarray, матрица натуральных вероятностей (m x m).\n",
    "    - delta: float, дисконтирующий фактор.\n",
    "    - z: numpy.ndarray, собственный вектор, связанный с delta.\n",
    "    \"\"\"\n",
    "    # Шаг 1: Находим максимальный собственный вектор и собственное значение для матрицы P\n",
    "    eigenvalues, eigenvectors = np.linalg.eig(p_matrix.T)  # используем транспонированную матрицу для поиска левого собственного вектора\n",
    "    idx = np.argmax(np.real(eigenvalues))  # находим индекс максимального собственного значения\n",
    "    delta = np.real(eigenvalues[idx])  # это значение соответствует дисконтирующему фактору\n",
    "    z = np.real(eigenvectors[:, idx])  # собственный вектор, связанный с delta\n",
    "    z = z / np.sum(z)  # нормализуем собственный вектор так, чтобы суммы элементов были равны 1\n",
    "    \n",
    "    # Шаг 2: Построение диагональной матрицы D на основе z\n",
    "    D = np.diag(1 / z)  # диагональная матрица с элементами 1/z_i\n",
    "    \n",
    "    # Шаг 3: Вычисляем матрицу натуральных вероятностей F\n",
    "    f_matrix = (1 / delta) * D @ p_matrix @ np.linalg.inv(D)\n",
    "    f_matrix.set_index(state_prices.index, inplace=True)\n",
    "    f_matrix.columns = state_prices.index\n",
    "    f_matrix = f_matrix.div(f_matrix.sum(axis=1), axis=0)\n",
    "    \n",
    "    return f_matrix, delta, z\n",
    "\n",
    "def distribution_from_markov_chain(markov_chain_matrix):\n",
    "    \"\"\"\n",
    "    Вычисляет приближенную плотность вероятности для стационарного распределения \n",
    "    Марковской цепи на основе заданной матрицы переходов.\n",
    "\n",
    "    Параметры:\n",
    "    ----------\n",
    "    markov_chain_matrix : pd.DataFrame\n",
    "        Квадратная матрица переходов Марковской цепи, где строки и столбцы \n",
    "        соответствуют состояниям, а элементы обозначают вероятности переходов \n",
    "        между состояниями.\n",
    "\n",
    "    Возвращает:\n",
    "    -----------\n",
    "    tuple[np.ndarray, np.ndarray]\n",
    "        pdf_values : np.ndarray\n",
    "            Значения плотности вероятности (после интерполяции и нормировки).\n",
    "        continuous_states : np.ndarray\n",
    "            Массив точек состояний, соответствующих значениям плотности вероятности.\n",
    "    \"\"\"\n",
    "    \n",
    "    # Получаем состояния из индекса матрицы\n",
    "    states = markov_chain_matrix.index\n",
    "\n",
    "    # Решение уравнения πP = π, добавив условие, что сумма π = 1\n",
    "    A = np.transpose(markov_chain_matrix) - np.eye(markov_chain_matrix.shape[0])\n",
    "    A = np.vstack([A, np.ones(markov_chain_matrix.shape[0])])\n",
    "    b = np.zeros(markov_chain_matrix.shape[0] + 1)\n",
    "    b[-1] = 1  # Сумма равна 1\n",
    "\n",
    "    # Решаем систему уравнений для нахождения стационарного распределения\n",
    "    pi = np.linalg.lstsq(A, b, rcond=None)[0]\n",
    "\n",
    "    # Нормируем стационарное распределение\n",
    "    pi = pi / np.sum(pi)  # Убедитесь, что сумма равна 1\n",
    "\n",
    "    # Фильтруем нулевые значения\n",
    "    non_zero_indices = pi > 0\n",
    "    pi = pi[non_zero_indices]\n",
    "    states = states[non_zero_indices]\n",
    "\n",
    "    return pi, states\n",
    "\n",
    "def calculate_moments(pi, states):\n",
    "    mean = np.sum(pi * states) # Вычисление среднего\n",
    "    \n",
    "    variance = np.sum(pi * (states - mean)**2) # Вычисление дисперсии и стандартного отклонения\n",
    "    std_dev = np.sqrt(variance)\n",
    "    \n",
    "    skewness = np.sum(pi * (states - mean)**3) / std_dev**3 # Вычисление асимметрии\n",
    "    \n",
    "    kurtosis = np.sum(pi * (states - mean)**4) / std_dev**4 - 3 # Вычисление эксцесса\n",
    "    \n",
    "    return mean, variance, skewness, kurtosis\n",
    "\n",
    "def get_recovered_density(data, instrument):\n",
    "    \n",
    "    selected_date = pd.to_datetime(dt_date.today())\n",
    "    undelying_last = (yf.download(instrument, start=(pd.to_datetime(dt_date.today()) - timedelta(days=100)), progress=False)['Close']).iloc[-1][-1]\n",
    "\n",
    "    dates = []\n",
    "    risk_neutral_std = []\n",
    "    risk_neutral_mean = []\n",
    "    recovered_std = []\n",
    "    recovered_mean = []\n",
    "    \n",
    "    iv_surface = data[['STRIKE', 'C_IV', 'Tenor']].copy().apply(pd.to_numeric, errors='coerce')\n",
    "    iv_surface = iv_surface.pivot_table(values='C_IV', index='STRIKE', columns='Tenor').dropna()\n",
    "    tenor = [round((i + 1) / 12, 4) for i in range(12)]\n",
    "    percent_changes = np.arange(-18, 21, 3) / 100\n",
    "    strike = undelying_last * (1 + percent_changes)\n",
    "\n",
    "    # Подготовка данных для интерполяции\n",
    "    iv_surface_empty = pd.DataFrame(index=strike, columns=tenor) # Создание сетки для интерполяции\n",
    "    X = iv_surface.columns.astype(float)\n",
    "    Y = iv_surface.index.astype(float)\n",
    "    Z = iv_surface.values\n",
    "    interp_func = RectBivariateSpline(Y, X, Z, kx=1, ky=1)\n",
    "    empty_matrix_tenor = iv_surface_empty.columns.astype(float)\n",
    "    empty_matrix_strike = iv_surface_empty.index.astype(float)\n",
    "    interpolated_values = interp_func(empty_matrix_strike, empty_matrix_tenor, grid=True)\n",
    "    iv_surface_interpolated = pd.DataFrame(interpolated_values, index=iv_surface_empty.index, columns=iv_surface_empty.columns).dropna()\n",
    "    iv_surface_interpolated.index.name = 'Strike'\n",
    "    iv_surface_interpolated.columns.name = 'Tenor'\n",
    "\n",
    "    ################ Option prices with interpolated implied volatility ################\n",
    "    ticker = \"^TNX\"  # Тикер для 10-летних государственных облигаций\n",
    "    start_date = selected_date - timedelta(days=7)\n",
    "    end_date = selected_date\n",
    "    interest_rate_data = yf.download(\"^TNX\", start=start_date, end=end_date, progress=False)\n",
    "    r = interest_rate_data['Close'].iloc[-1][-1] / 100\n",
    "\n",
    "    call_prices = pd.DataFrame(index=iv_surface_interpolated.index, columns=iv_surface_interpolated.columns)\n",
    "    for tenor in iv_surface_interpolated.columns:\n",
    "        for strike in iv_surface_interpolated.index:\n",
    "            volatility = iv_surface_interpolated.loc[strike, tenor]\n",
    "            call_prices.loc[strike, tenor] = black_scholes_call(undelying_last, strike, r, tenor, volatility)\n",
    "\n",
    "    ################ State price matrix ################\n",
    "\n",
    "    state_prices = pd.DataFrame(index=call_prices.index, columns=call_prices.columns) # State price matrix (Breeden-Litzenberg) \n",
    "\n",
    "    for i in range(1, len(call_prices.index) - 1):\n",
    "        for j in range(len(call_prices.columns)):\n",
    "            state_prices.iloc[i, j] = np.exp(r * call_prices.columns[i]) * (\n",
    "                call_prices.iloc[i + 1, j] - 2 * call_prices.iloc[i, j] + call_prices.iloc[i - 1, j]) / (\n",
    "                    (call_prices.index[i+1] - call_prices.index[i])**2)\n",
    "\n",
    "    state_prices = state_prices.iloc[1:-1].copy()\n",
    "    state_prices[state_prices < 0] = 0\n",
    "\n",
    "    first_column_sum = state_prices.iloc[:, 0].sum()\n",
    "    state_prices.iloc[:, 0] = state_prices.iloc[:, 0] / first_column_sum\n",
    "\n",
    "    central_row = state_prices.index[len(state_prices) // 2]\n",
    "    percent_change = (state_prices.index - central_row) / central_row\n",
    "    percent_change = pd.Series(percent_change).round(2)\n",
    "    state_prices.index = percent_change\n",
    "\n",
    "    ################ calculate_p_matrix ################\n",
    "\n",
    "    p_matrix = calculate_p_matrix(state_prices)\n",
    "\n",
    "    ################ Risk neutral moments ################\n",
    "\n",
    "    pdf_rn, continious_states_rn = distribution_from_markov_chain(p_matrix)\n",
    "    pdf_rn_df = pd.DataFrame(pdf_rn.reshape(1, -1), columns=continious_states_rn) # Плотность\n",
    "    rn_mean, rn_std, rn_skewness, rn_kurtosis = calculate_moments(pdf_rn, continious_states_rn) #  Моменты\n",
    "\n",
    "    ################ calculate_f_matrix ################\n",
    "\n",
    "    f_matrix, _, _ = calculate_f_matrix(p_matrix, state_prices)\n",
    "\n",
    "    ################ Ross recovery moments ################\n",
    "\n",
    "    pdf_recovered, continious_states_recovered = distribution_from_markov_chain(f_matrix)\n",
    "    pdf_recovered_df = pd.DataFrame(pdf_recovered.reshape(1, -1), columns=continious_states_recovered) # Плотность\n",
    "    rec_mean, rec_std, rec_skewness, rec_kurtosis = calculate_moments(pdf_recovered, continious_states_recovered) # Моменты\n",
    "    \n",
    "    selected_date = [pd.Timestamp(selected_date)]\n",
    "    recovered_data = pd.DataFrame({\n",
    "        'risk_neutral_mean':rn_mean, \n",
    "        'risk_neutral_std':rn_std,\n",
    "        'recovered_mean':rec_mean, \n",
    "        'recovered_std':rec_std\n",
    "    }, index=selected_date)\n",
    "    \n",
    "    recovered_data['risk_premium'] = (recovered_data['recovered_mean'] - recovered_data['risk_neutral_mean'])\n",
    "    recovered_data['risk_preference'] = (recovered_data['recovered_std'] - recovered_data['risk_neutral_std'])\n",
    "\n",
    "    return recovered_data, pdf_recovered_df\n",
    "\n",
    "def create_copula(pdf_recovered_spy, pdf_recovered_qqq):\n",
    "    pdf_combined = pd.concat([pdf_recovered_spy, pdf_recovered_qqq], axis=1, keys=['pdf_recovered_spy', 'pdf_recovered_qqq'], join='inner')\n",
    "\n",
    "    spy_qqq_returns = yf.download(['SPY', 'QQQ'], start=(pd.to_datetime(dt_date.today()) - timedelta(days=500)), progress=False)['Close']\n",
    "    spy_qqq_returns = spy_qqq_returns.pct_change().dropna()\n",
    "    observe_date = spy_qqq_returns.index[-1]\n",
    "    days_for_stats = 30*6\n",
    "    \n",
    "    pdf_to_copula = pd.concat([pdf_combined['pdf_recovered_spy'], pdf_combined['pdf_recovered_qqq']], axis=0).astype(float).T\n",
    "    pdf_to_copula.index = pdf_to_copula.index.astype(float)\n",
    "    pdf_to_copula.columns = ['spy_pdf_recovered', 'qqq_pdf_recovered']\n",
    "    \n",
    "    # Накопительные функции распределения (CDF)\n",
    "    pdf_to_copula['cdf_spy'] = pdf_to_copula['spy_pdf_recovered'].cumsum() / pdf_to_copula['spy_pdf_recovered'].sum()\n",
    "    pdf_to_copula['cdf_qqq'] = pdf_to_copula['qqq_pdf_recovered'].cumsum() / pdf_to_copula['qqq_pdf_recovered'].sum()\n",
    "    \n",
    "    # Параметры копулы\n",
    "    spy_qqq_corr = spy_qqq_returns[(spy_qqq_returns.index > pd.to_datetime(dt_date.today()) - timedelta(days=days_for_stats)) & \n",
    "                                   (spy_qqq_returns.index <= pd.to_datetime(dt_date.today()))]\n",
    "    correlation = spy_qqq_corr['SPY'].corr(spy_qqq_corr['QQQ'])\n",
    "    cov_matrix = [[1, correlation], [correlation, 1]]\n",
    "    \n",
    "    cov_matrix = [[1, correlation], [correlation, 1]]\n",
    "    \n",
    "    df = 5  # Степени свободы для t-распределения\n",
    "    \n",
    "    # Сгенерируем t-копулу\n",
    "    num_samples = 500\n",
    "    copula_samples = multivariate_t.rvs(loc=[0, 0], shape=cov_matrix, df=df, size=num_samples)\n",
    "    \n",
    "    # Применим стандартную нормальную CDF для перехода от нормальных квантилей к [0,1]\n",
    "    u = norm.cdf(copula_samples[:, 0])\n",
    "    v = norm.cdf(copula_samples[:, 1])\n",
    "    \n",
    "    # Преобразуем квантильные значения обратно в состояния SPY и QQQ\n",
    "    spy_states = np.interp(u, pdf_to_copula['cdf_spy'], pdf_to_copula.index)\n",
    "    qqq_states = np.interp(v, pdf_to_copula['cdf_qqq'], pdf_to_copula.index)\n",
    "    \n",
    "    bootstrap_sample_indices = np.random.choice(len(spy_states), len(spy_states), replace=True)\n",
    "    bootstrap_spy_states = spy_states[bootstrap_sample_indices]\n",
    "    bootstrap_qqq_states = qqq_states[bootstrap_sample_indices]\n",
    "    \n",
    "    copula_results = pd.DataFrame({\n",
    "        'date': [spy_qqq_returns.index[-1]],\n",
    "        'bootstrap_mean_spy': [np.mean(bootstrap_spy_states)],\n",
    "        'bootstrap_std_spy': [np.std(bootstrap_spy_states)],\n",
    "        'bootstrap_skew_spy': [skew(bootstrap_spy_states)],\n",
    "        'bootstrap_kurtosis_spy': [kurtosis(bootstrap_spy_states)],\n",
    "        'bootstrap_mean_qqq': [np.mean(bootstrap_qqq_states)],\n",
    "        'bootstrap_std_qqq': [np.std(bootstrap_qqq_states)],\n",
    "        'bootstrap_skew_qqq': [skew(bootstrap_qqq_states)],\n",
    "        'bootstrap_kurtosis_qqq': [kurtosis(bootstrap_qqq_states)]\n",
    "    })\n",
    "\n",
    "    return copula_results, spy_states, qqq_states, observe_date\n",
    "\n",
    "def copula_plot(spy_states, qqq_states):\n",
    "    # Оценка плотности KDE\n",
    "    kde = gaussian_kde([spy_states, qqq_states])\n",
    "    \n",
    "    # Создаём сетку для оценки\n",
    "    x = np.linspace(spy_states.min(), spy_states.max(), 100)\n",
    "    y = np.linspace(qqq_states.min(), qqq_states.max(), 100)\n",
    "    X, Y = np.meshgrid(x, y)\n",
    "    Z = kde(np.vstack([X.ravel(), Y.ravel()])).reshape(X.shape)\n",
    "    fig = go.Figure(data=[go.Surface(z=Z, x=X, y=Y, colorscale=\"plasma\")])\n",
    "    fig.update_layout(\n",
    "        title=f\"Density Plot of SPY and QQQ States on {observe_date.strftime('%Y-%m-%d')}\",\n",
    "        scene=dict(\n",
    "            xaxis_title=\"SPY ETF State\",\n",
    "            yaxis_title=\"QQQ ETF State\",\n",
    "            zaxis_title=\"Density\"\n",
    "        )\n",
    "    )\n",
    "    \n",
    "    fig.show()\n",
    "    \n",
    "def lstm_forecast(copula_results, spy_lstm_model, qqq_lstm_model, scaler_spy_lstm, scaler_qqq_lstm):\n",
    "    def calculate_realized_volatility(data, window):\n",
    "        data['log_returns'] = np.log(data['Close'] / data['Close'].shift(1))\n",
    "        data['sqrt_returns'] = data['log_returns']**2\n",
    "        data['rv_t'] = data['sqrt_returns'].rolling(window=window).mean().apply(np.sqrt)\n",
    "        return data['rv_t']\n",
    "    \n",
    "    spy_data = yf.download('SPY', start=(pd.to_datetime(dt_date.today()) - timedelta(days=300)), progress=False)\n",
    "    spy_data = pd.DataFrame(calculate_realized_volatility(spy_data, window=21)).dropna()\n",
    "    spy_data['rv_t-5'] = spy_data['rv_t'].rolling(5).mean()\n",
    "    spy_data['rv_t-21'] = spy_data['rv_t'].rolling(21).mean()\n",
    "    spy_data.dropna(inplace=True)\n",
    "    \n",
    "    qqq_data = yf.download('QQQ', start=(pd.to_datetime(dt_date.today()) - timedelta(days=300)), progress=False)\n",
    "    qqq_data = pd.DataFrame(calculate_realized_volatility(qqq_data, window=21)).dropna()\n",
    "    qqq_data['rv_t-5'] = qqq_data['rv_t'].rolling(5).mean()\n",
    "    qqq_data['rv_t-21'] = qqq_data['rv_t'].rolling(21).mean()\n",
    "    qqq_data.dropna(inplace=True)\n",
    "    \n",
    "    spy_forecast_data = copula_results[['bootstrap_mean_spy', 'bootstrap_std_spy', 'bootstrap_skew_spy', 'bootstrap_kurtosis_spy']]\n",
    "    spy_forecast_data.columns = ['mean', 'std', 'skewness', 'kurtosis']\n",
    "    spy_forecast_data['rv_t'] = spy_data['rv_t'][-1]\n",
    "    spy_forecast_data['rv_t-5'] = spy_data['rv_t-5'][-1]\n",
    "    spy_forecast_data['rv_t-21'] = spy_data['rv_t-21'][-1]\n",
    "    \n",
    "    qqq_forecast_data = copula_results[['bootstrap_mean_qqq', 'bootstrap_std_qqq', 'bootstrap_skew_qqq', 'bootstrap_kurtosis_qqq']]\n",
    "    qqq_forecast_data.columns = ['mean', 'std', 'skewness', 'kurtosis']\n",
    "    qqq_forecast_data['rv_t'] = qqq_data['rv_t'][-1]\n",
    "    qqq_forecast_data['rv_t-5'] = qqq_data['rv_t-5'][-1]\n",
    "    qqq_forecast_data['rv_t-21'] = qqq_data['rv_t-21'][-1]\n",
    "    \n",
    "    spy_forecast_scaled_data = scaler_spy_lstm.transform(spy_forecast_data)\n",
    "    qqq_forecast_scaled_data = scaler_qqq_lstm.transform(qqq_forecast_data)\n",
    "    \n",
    "    spy_forecast_scaled_data = spy_forecast_scaled_data.reshape(spy_forecast_scaled_data.shape[0], 1, spy_forecast_scaled_data.shape[1])\n",
    "    qqq_forecast_scaled_data = qqq_forecast_scaled_data.reshape(qqq_forecast_scaled_data.shape[0], 1, qqq_forecast_scaled_data.shape[1])\n",
    "    \n",
    "    spy_rv_predictions = spy_lstm_model.predict(spy_forecast_scaled_data)\n",
    "    qqq_rv_predictions = qqq_lstm_model.predict(qqq_forecast_scaled_data)\n",
    "\n",
    "    return spy_rv_predictions, qqq_rv_predictions, spy_forecast_data, qqq_forecast_data, spy_data, qqq_data\n",
    "\n",
    "def plot_forecast(spy_data, spy_rv_predictions, qqq_data, qqq_rv_predictions):\n",
    "    # график rv spy\n",
    "    step = 5\n",
    "    # Получение столбца с реализованной волатильностью\n",
    "    realized_volatility = spy_data['rv_t']\n",
    "    # Определение последнего индекса и расчет будущих индексов с шагом step\n",
    "    last_index = realized_volatility.index[-1]\n",
    "    future_indices = [last_index + pd.DateOffset(days=i * step) for i in range(1, spy_rv_predictions.shape[1] + 1)]\n",
    "    # Преобразуем spy_rv_predictions в одномерный массив\n",
    "    spy_rv_predictions = spy_rv_predictions.flatten()\n",
    "    # Создаем фигуру\n",
    "    fig = go.Figure()\n",
    "    # Линия реализованной волатильности\n",
    "    fig.add_trace(go.Scatter(\n",
    "    x=realized_volatility.index,\n",
    "    y=realized_volatility,\n",
    "    mode='lines',\n",
    "    name='Realized Volatility',\n",
    "    line=dict(color='black', width=2)\n",
    "    ))\n",
    "    \n",
    "    # Точки предсказанных значений\n",
    "    fig.add_trace(go.Scatter(\n",
    "    x=future_indices,\n",
    "    y=spy_rv_predictions,\n",
    "    mode='markers',\n",
    "    name='Predicted Volatility',\n",
    "    marker=dict(color='red', size=8),\n",
    "    hoverinfo='x+y'\n",
    "    ))\n",
    "    \n",
    "    # Соединяющая линия прогнозов\n",
    "    x_values = [last_index] + future_indices\n",
    "    y_values = [realized_volatility.iloc[-1]] + spy_rv_predictions.tolist()\n",
    "    \n",
    "    fig.add_trace(go.Scatter(\n",
    "    x=x_values,\n",
    "    y=y_values,\n",
    "    mode='lines',\n",
    "    name='Forecast Line',\n",
    "    line=dict(color='coral', width=2, dash='dash')\n",
    "    ))\n",
    "    \n",
    "    # Настройка осей\n",
    "    fig.update_layout(\n",
    "    width=1000,  # Ширина фигуры\n",
    "    height=500,  # Высота фигуры\n",
    "    title=f\"SPY Realized Volatility Forecast {observe_date.strftime('%Y-%m-%d')}\",\n",
    "    xaxis=dict(\n",
    "        title=\"Date\",\n",
    "        tickformat='%b %d, %Y',  # Формат дат: \"Jan 10, 2025\"\n",
    "        showgrid=True\n",
    "    ),\n",
    "    yaxis=dict(\n",
    "        title=\"Realized Volatility, σ\",\n",
    "        showgrid=True\n",
    "    ),\n",
    "    legend=dict(\n",
    "        x=0.01, y=0.99, bgcolor='rgba(255,255,255,0.7)'\n",
    "    )\n",
    "    )\n",
    "    # Показать график\n",
    "    fig.show()\n",
    "    \n",
    "    # график rv qqq\n",
    "    realized_volatility = qqq_data['rv_t']\n",
    "    last_index = realized_volatility.index[-1]\n",
    "    future_indices = [last_index + pd.DateOffset(days=i * step) for i in range(1, qqq_rv_predictions.shape[1] + 1)]\n",
    "    qqq_rv_predictions = qqq_rv_predictions.flatten()\n",
    "    \n",
    "    fig = go.Figure()\n",
    "    fig.add_trace(go.Scatter(\n",
    "    x=realized_volatility.index,\n",
    "    y=realized_volatility,\n",
    "    mode='lines',\n",
    "    name='Realized Volatility',\n",
    "    line=dict(color='black', width=2)\n",
    "    ))\n",
    "    fig.add_trace(go.Scatter(\n",
    "    x=future_indices,\n",
    "    y=qqq_rv_predictions,\n",
    "    mode='markers',\n",
    "    name='Predicted Volatility',\n",
    "    marker=dict(color='red', size=8),\n",
    "    hoverinfo='x+y'\n",
    "    ))\n",
    "    x_values = [last_index] + future_indices\n",
    "    y_values = [realized_volatility.iloc[-1]] + qqq_rv_predictions.tolist()\n",
    "    fig.add_trace(go.Scatter(\n",
    "    x=x_values,\n",
    "    y=y_values,\n",
    "    mode='lines',\n",
    "    name='Forecast Line',\n",
    "    line=dict(color='coral', width=2, dash='dash')\n",
    "    ))\n",
    "    fig.update_layout(\n",
    "    width=1000,  # Ширина фигуры\n",
    "    height=500,  # Высота фигуры\n",
    "    title=f\"QQQ Realized Volatility Forecast from {observe_date.strftime('%Y-%m-%d')}\",\n",
    "    xaxis=dict(\n",
    "        title=\"Date\",\n",
    "        tickformat='%b %d, %Y',  # Формат дат: \"Jan 10, 2025\"\n",
    "        showgrid=True\n",
    "    ),\n",
    "    yaxis=dict(\n",
    "        title=\"Realized Volatility, σ\",\n",
    "        showgrid=True\n",
    "    ),\n",
    "    legend=dict(\n",
    "        x=0.01, y=0.99, bgcolor='rgba(255,255,255,0.7)'\n",
    "    )\n",
    "    )\n",
    "    fig.show()\n",
    "\n",
    "def option_trading_recomendation(spy_forecast_data, qqq_forecast_data, spy_rv_predictions, qqq_rv_predictions):\n",
    "    spy_forecast_data['rv_pred_t+5'] = spy_rv_predictions[0, 0]\n",
    "    spy_forecast_data['rv_pred_t+10'] = spy_rv_predictions[0, 1]\n",
    "    spy_forecast_data['rv_pred_t+15'] = spy_rv_predictions[0, 2]\n",
    "    spy_forecast_data['rv_pred_t+20'] = spy_rv_predictions[0, 3]\n",
    "    \n",
    "    qqq_forecast_data['rv_pred_t+5'] = qqq_rv_predictions[0, 0]\n",
    "    qqq_forecast_data['rv_pred_t+10'] = qqq_rv_predictions[0, 1]\n",
    "    qqq_forecast_data['rv_pred_t+15'] = qqq_rv_predictions[0, 2]\n",
    "    qqq_forecast_data['rv_pred_t+20'] = qqq_rv_predictions[0, 3]\n",
    "    \n",
    "    print('SPY')\n",
    "    print('\\nvega-scalping:')\n",
    "    if spy_forecast_data['rv_pred_t+5'][0] >= spy_forecast_data['rv_t'][0] * 1.05:\n",
    "        growth = spy_forecast_data['rv_pred_t+5'][0] / spy_forecast_data['rv_t'][0] - 1\n",
    "        print(f\"5-дн рост RV по SPY > 5% (прогноз {growth:.2%}), стратегия: vega-scalping на колл-опционах SPY (наибольшая vega, экспирация опционов от {(observe_date + timedelta(5-3)).strftime('%Y-%m-%d')} до {(observe_date + timedelta(5+3)).strftime('%Y-%m-%d')})\")\n",
    "        print('статистика стратегии: коэф. Шарпа (0.65), winrate (44%), ожидаемая доходность (12%), сделок (558), средняя vega (23.40)')\n",
    "    if spy_forecast_data['rv_pred_t+5'][0] >= spy_forecast_data['rv_t'][0] * 1.1:\n",
    "        growth = spy_forecast_data['rv_pred_t+5'][0] / spy_forecast_data['rv_t'][0] - 1\n",
    "        print(f\"5-дн рост RV по SPY > 10% (прогноз {growth:.2%}), стратегия: vega-scalping на колл-опционах SPY (наибольшая vega, экспирация опционов от {(observe_date + timedelta(5-3)).strftime('%Y-%m-%d')} до {(observe_date + timedelta(5+3)).strftime('%Y-%m-%d')})\")\n",
    "        print('статистика стратегии: коэф. Шарпа (0.62), winrate (44%), ожидаемая доходность (11%), сделок (380), средняя vega (23.67)')\n",
    "    if spy_forecast_data['rv_pred_t+5'][0] >= spy_forecast_data['rv_t'][0] * 1.15:\n",
    "        growth = spy_forecast_data['rv_pred_t+5'][0] / spy_forecast_data['rv_t'][0] - 1\n",
    "        print(f\"5-дн рост RV по SPY > 15% (прогноз {growth:.2%}), стратегия: vega-scalping на колл-опционах SPY (наибольшая vega, экспирация опционов от {(observe_date + timedelta(5-3)).strftime('%Y-%m-%d')} до {(observe_date + timedelta(5+3)).strftime('%Y-%m-%d')})\")\n",
    "        print('статистика стратегии: коэф. Шарпа (0.82), winrate (45%), ожидаемая доходность (15%), сделок (198), средняя vega (23.58)')\n",
    "    if spy_forecast_data['rv_pred_t+10'][0] >= spy_forecast_data['rv_t'][0] * 1.05:\n",
    "        growth = spy_forecast_data['rv_pred_t+10'][0] / spy_forecast_data['rv_t'][0] - 1\n",
    "        print(f\"10-дн рост RV по SPY > 5% (прогноз {growth:.2%}), стратегия: vega-scalping на колл-опционах SPY (наибольшая vega, экспирация опционов от {(observe_date + timedelta(10-3)).strftime('%Y-%m-%d')} до {(observe_date + timedelta(10+3)).strftime('%Y-%m-%d')})\")\n",
    "        print('статистика стратегии: коэф. Шарпа (0.65), winrate (47%), ожидаемая доходность (16%), сделок (312), средняя vega (29.95)')\n",
    "    if spy_forecast_data['rv_pred_t+10'][0] >= spy_forecast_data['rv_t'][0] * 1.1:\n",
    "        growth = spy_forecast_data['rv_pred_t+10'][0] / spy_forecast_data['rv_t'][0] - 1\n",
    "        print(f\"10-дн рост RV по SPY > 10% (прогноз {growth:.2%}), стратегия: vega-scalping на колл-опционах SPY (наибольшая vega, экспирация опционов от {(observe_date + timedelta(10-3)).strftime('%Y-%m-%d')} до {(observe_date + timedelta(10+3)).strftime('%Y-%m-%d')})\")\n",
    "        print('статистика стратегии: коэф. Шарпа (0.67), winrate (47%), ожидаемая доходность (17%), сделок (208), средняя vega (30.00)')\n",
    "    if spy_forecast_data['rv_pred_t+10'][0] >= spy_forecast_data['rv_t'][0] * 1.15:\n",
    "        growth = spy_forecast_data['rv_pred_t+10'][0] / spy_forecast_data['rv_t'][0] - 1\n",
    "        print(f\"10-дн рост RV по SPY > 15% (прогноз {growth:.2%}), стратегия: vega-scalping на колл-опционах SPY (наибольшая vega, экспирация опционов от {(observe_date + timedelta(10-3)).strftime('%Y-%m-%d')} до {(observe_date + timedelta(10+3)).strftime('%Y-%m-%d')})\")\n",
    "        print('статистика стратегии: коэф. Шарпа (0.69), winrate (48%), ожидаемая доходность (16%), сделок (124), средняя vega (30.04)')\n",
    "    if spy_forecast_data['rv_pred_t+10'][0] <= spy_forecast_data['rv_t'][0] * 0.95:\n",
    "        growth = spy_forecast_data['rv_pred_t+10'][0] / spy_forecast_data['rv_t'][0] - 1\n",
    "        print(f\"10-дн падение RV по SPY > 5% (прогноз {growth:.2%}), стратегия: vega-scalping на колл-опционах SPY (наибольшая vega, экспирация опционов от {(observe_date + timedelta(10-3)).strftime('%Y-%m-%d')} до {(observe_date + timedelta(10+3)).strftime('%Y-%m-%d')})\")\n",
    "        print('статистика стратегии: коэф. Шарпа (0.52), winrate (45%), ожидаемая доходность (13%), сделок (246), средняя vega (29.58)')\n",
    "    if spy_forecast_data['rv_pred_t+10'][0] <= spy_forecast_data['rv_t'][0] * 0.9:\n",
    "        growth = spy_forecast_data['rv_pred_t+10'][0] / spy_forecast_data['rv_t'][0] - 1\n",
    "        print(f\"10-дн падение RV по SPY > 10% (прогноз {growth:.2%}), стратегия: vega-scalping на колл-опционах SPY (наибольшая vega, экспирация опционов от {(observe_date + timedelta(10-3)).strftime('%Y-%m-%d')} до {(observe_date + timedelta(10+3)).strftime('%Y-%m-%d')})\")\n",
    "        print('статистика стратегии: коэф. Шарпа (0.61), winrate (44%), ожидаемая доходность (15%), сделок (127), средняя vega (29.17)')\n",
    "    if spy_forecast_data['rv_pred_t+20'][0] >= spy_forecast_data['rv_t'][0] * 1.05:\n",
    "        growth = spy_forecast_data['rv_pred_t+20'][0] / spy_forecast_data['rv_t'][0] - 1\n",
    "        print(f\"20-дн рост RV по SPY > 5% (прогноз {growth:.2%}), стратегия: vega-scalping на колл-опционах SPY (наибольшая vega, экспирация опционов от {(observe_date + timedelta(20-3)).strftime('%Y-%m-%d')} до {(observe_date + timedelta(20+3)).strftime('%Y-%m-%d')})\")\n",
    "        print('статистика стратегии: коэф. Шарпа (0.59), winrate (51%), ожидаемая доходность (20%), сделок (251), средняя vega (39.59)')\n",
    "    if spy_forecast_data['rv_pred_t+20'][0] <= spy_forecast_data['rv_t'][0] * 0.85:\n",
    "        growth = spy_forecast_data['rv_pred_t+20'][0] / spy_forecast_data['rv_t'][0] - 1\n",
    "        print(f\"20-дн падение RV по SPY > 15% (прогноз {growth:.2%}), стратегия: vega-scalping на колл-опционах SPY (наибольшая vega, экспирация опционов от {(observe_date + timedelta(20-3)).strftime('%Y-%m-%d')} до {(observe_date + timedelta(20+3)).strftime('%Y-%m-%d')})\")\n",
    "        print('статистика стратегии: коэф. Шарпа (0.58), winrate (48%), ожидаемая доходность (22%), сделок (238), средняя vega (39.21)')\n",
    "\n",
    "    print('\\ndelta-scalping:')\n",
    "    if spy_forecast_data['rv_pred_t+10'][0] >= spy_forecast_data['rv_t'][0] * 1.15:\n",
    "        growth = spy_forecast_data['rv_pred_t+10'][0] / spy_forecast_data['rv_t'][0] - 1\n",
    "        print(f\"10-дн рост RV по SPY > 15% (прогноз {growth:.2%}), стратегия: delta-scalping на колл-опционах SPY (наибольшая delta, экспирация опционов от {(observe_date + timedelta(10-3)).strftime('%Y-%m-%d')} до {(observe_date + timedelta(10+3)).strftime('%Y-%m-%d')})\")\n",
    "        print('статистика стратегии: коэф. Шарпа (0.94), winrate (62%), ожидаемая доходность (11%), сделок (123), средняя delta (0.85)')\n",
    "    if spy_forecast_data['rv_pred_t+20'][0] >= spy_forecast_data['rv_t'][0] * 1.05:\n",
    "        growth = spy_forecast_data['rv_pred_t+20'][0] / spy_forecast_data['rv_t'][0] - 1\n",
    "        print(f\"20-дн рост RV по SPY > 5% (прогноз {growth:.2%}), стратегия: delta-scalping на колл-опционах SPY (наибольшая delta, экспирация опционов от {(observe_date + timedelta(20-3)).strftime('%Y-%m-%d')} до {(observe_date + timedelta(20+3)).strftime('%Y-%m-%d')})\")\n",
    "        print('статистика стратегии: коэф. Шарпа (0.82), winrate (61%), ожидаемая доходность (16%), сделок (246), средняя delta (0.80)')\n",
    "    if spy_forecast_data['rv_pred_t+20'][0] >= spy_forecast_data['rv_t'][0] * 1.10:\n",
    "        growth = spy_forecast_data['rv_pred_t+20'][0] / spy_forecast_data['rv_t'][0] - 1\n",
    "        print(f\"20-дн рост RV по SPY > 10% (прогноз {growth:.2%}), стратегия: delta-scalping на колл-опционах SPY (наибольшая delta, экспирация опционов от {(observe_date + timedelta(20-3)).strftime('%Y-%m-%d')} до {(observe_date + timedelta(20+3)).strftime('%Y-%m-%d')})\")\n",
    "        print('статистика стратегии: коэф. Шарпа (0.88), winrate (58%), ожидаемая доходность (16%), сделок (172), средняя delta (0.81)')\n",
    "    if spy_forecast_data['rv_pred_t+20'][0] >= spy_forecast_data['rv_t'][0] * 1.15:\n",
    "        growth = spy_forecast_data['rv_pred_t+20'][0] / spy_forecast_data['rv_t'][0] - 1\n",
    "        print(f\"20-дн рост RV по SPY > 15% (прогноз {growth:.2%}), стратегия: delta-scalping на колл-опционах SPY (наибольшая delta, экспирация опционов от {(observe_date + timedelta(20-3)).strftime('%Y-%m-%d')} до {(observe_date + timedelta(20+3)).strftime('%Y-%m-%d')})\")\n",
    "        print('статистика стратегии: коэф. Шарпа (1.06), winrate (59%), ожидаемая доходность (16%), сделок (115), средняя delta (0.83)')\n",
    "        \n",
    "    print('\\nstraddle:')\n",
    "    if spy_forecast_data['rv_pred_t+10'][0] <= spy_forecast_data['rv_t'][0] * 0.9:\n",
    "        growth = spy_forecast_data['rv_pred_t+10'][0] / spy_forecast_data['rv_t'][0] - 1\n",
    "        print(f\"10-дн падение RV по SPY > 10% (прогноз {growth:.2%}), стратегия: straddle на опционах SPY (самые дальние от страйка колл- и пут-опционы, экспирация опционов от {(observe_date + timedelta(10-3)).strftime('%Y-%m-%d')} до {(observe_date + timedelta(10+3)).strftime('%Y-%m-%d')})\")\n",
    "        print('статистика стратегии: коэф. Шарпа (0.35), winrate (59%), ожидаемая доходность (4%), сделок (129)')\n",
    "    if spy_forecast_data['rv_pred_t+15'][0] <= spy_forecast_data['rv_t'][0] * 0.9:\n",
    "        growth = spy_forecast_data['rv_pred_t+15'][0] / spy_forecast_data['rv_t'][0] - 1\n",
    "        print(f\"15-дн падение RV по SPY > 10% (прогноз {growth:.2%}), стратегия: straddle на опционах SPY (самые дальние от страйка колл- и пут-опционы, экспирация опционов от {(observe_date + timedelta(15-3)).strftime('%Y-%m-%d')} до {(observe_date + timedelta(15+3)).strftime('%Y-%m-%d')})\")\n",
    "        print('статистика стратегии: коэф. Шарпа (0.32), winrate (54%), ожидаемая доходность (5%), сделок (172)')\n",
    "    if spy_forecast_data['rv_pred_t+20'][0] <= spy_forecast_data['rv_t'][0] * 0.95:\n",
    "        growth = spy_forecast_data['rv_pred_t+20'][0] / spy_forecast_data['rv_t'][0] - 1\n",
    "        print(f\"20-дн падение RV по SPY > 5% (прогноз {growth:.2%}), стратегия: straddle на опционах SPY (самые дальние от страйка колл- и пут-опционы, экспирация опционов от {(observe_date + timedelta(20-3)).strftime('%Y-%m-%d')} до {(observe_date + timedelta(20+3)).strftime('%Y-%m-%d')})\")\n",
    "        print('статистика стратегии: коэф. Шарпа (0.35), winrate (56%), ожидаемая доходность (6%), сделок (378)')\n",
    "    if spy_forecast_data['rv_pred_t+20'][0] <= spy_forecast_data['rv_t'][0] * 0.9:\n",
    "        growth = spy_forecast_data['rv_pred_t+20'][0] / spy_forecast_data['rv_t'][0] - 1\n",
    "        print(f\"20-дн падение RV по SPY > 10% (прогноз {growth:.2%}), стратегия: straddle на опционах SPY (самые дальние от страйка колл- и пут-опционы, экспирация опционов от {(observe_date + timedelta(20-3)).strftime('%Y-%m-%d')} до {(observe_date + timedelta(20+3)).strftime('%Y-%m-%d')})\")\n",
    "        print('статистика стратегии: коэф. Шарпа (0.36), winrate (57%), ожидаемая доходность (6%), сделок (305)')\n",
    "    if spy_forecast_data['rv_pred_t+20'][0] <= spy_forecast_data['rv_t'][0] * 0.85:\n",
    "        growth = spy_forecast_data['rv_pred_t+20'][0] / spy_forecast_data['rv_t'][0] - 1\n",
    "        print(f\"20-дн падение RV по SPY > 15% (прогноз {growth:.2%}), стратегия: straddle на опционах SPY (самые дальние от страйка колл- и пут-опционы, экспирация опционов от {(observe_date + timedelta(20-3)).strftime('%Y-%m-%d')} до {(observe_date + timedelta(20+3)).strftime('%Y-%m-%d')})\")\n",
    "        print('статистика стратегии: коэф. Шарпа (0.32), winrate (57%), ожидаемая доходность (5%), сделок (230)')\n",
    "\n",
    "    print('\\nQQQ')\n",
    "    print('\\nvega-scalping:')\n",
    "    if qqq_forecast_data['rv_pred_t+5'][0] >= qqq_forecast_data['rv_t'][0] * 1.05:\n",
    "        growth = qqq_forecast_data['rv_pred_t+5'][0] / qqq_forecast_data['rv_t'][0] - 1\n",
    "        print(f\"5-дн рост RV по QQQ > 5% (прогноз {growth:.2%}), стратегия: vega-scalping на колл-опционах QQQ (наибольшая vega, экспирация опционов от {(observe_date + timedelta(5-3)).strftime('%Y-%m-%d')} до {(observe_date + timedelta(5+3)).strftime('%Y-%m-%d')})\")\n",
    "        print('статистика стратегии: коэф. Шарпа (1.37), winrate (52%), ожидаемая доходность (26%), сделок (112), средняя vega (18.21)')\n",
    "    if qqq_forecast_data['rv_pred_t+10'][0] >= qqq_forecast_data['rv_t'][0] * 1.05:\n",
    "        growth = qqq_forecast_data['rv_pred_t+10'][0] / qqq_forecast_data['rv_t'][0] - 1\n",
    "        print(f\"10-дн рост RV по QQQ > 5% (прогноз {growth:.2%}), стратегия: vega-scalping на колл-опционах QQQ (наибольшая vega, экспирация опционов от {(observe_date + timedelta(10-3)).strftime('%Y-%m-%d')} до {(observe_date + timedelta(10+3)).strftime('%Y-%m-%d')})\")\n",
    "        print('статистика стратегии: коэф. Шарпа (1.23), winrate (51%), ожидаемая доходность (33%), сделок (174), средняя vega (23.65)')\n",
    "    if qqq_forecast_data['rv_pred_t+15'][0] >= qqq_forecast_data['rv_t'][0] * 1.05:\n",
    "        growth = qqq_forecast_data['rv_pred_t+15'][0] / qqq_forecast_data['rv_t'][0] - 1\n",
    "        print(f\"15-дн рост RV по QQQ > 5% (прогноз {growth:.2%}), стратегия: vega-scalping на колл-опционах QQQ (наибольшая vega, экспирация опционов от {(observe_date + timedelta(15-3)).strftime('%Y-%m-%d')} до {(observe_date + timedelta(15+3)).strftime('%Y-%m-%d')})\")\n",
    "        print('статистика стратегии: коэф. Шарпа (1.12), winrate (52%), ожидаемая доходность (40%), сделок (207), средняя vega (28.71)')\n",
    "    if qqq_forecast_data['rv_pred_t+15'][0] >= qqq_forecast_data['rv_t'][0] * 1.1:\n",
    "        growth = qqq_forecast_data['rv_pred_t+15'][0] / qqq_forecast_data['rv_t'][0] - 1\n",
    "        print(f\"15-дн рост RV по QQQ > 10% (прогноз {growth:.2%}), стратегия: vega-scalping на колл-опционах QQQ (наибольшая vega, экспирация опционов от {(observe_date + timedelta(15-3)).strftime('%Y-%m-%d')} до {(observe_date + timedelta(15+3)).strftime('%Y-%m-%d')})\")\n",
    "        print('статистика стратегии: коэф. Шарпа (1.15), winrate (52%), ожидаемая доходность (39%), сделок (143), средняя vega (29.16)')\n",
    "    if qqq_forecast_data['rv_pred_t+20'][0] >= qqq_forecast_data['rv_t'][0] * 1.05:\n",
    "        growth = qqq_forecast_data['rv_pred_t+20'][0] / qqq_forecast_data['rv_t'][0] - 1\n",
    "        print(f\"20-дн рост RV по QQQ > 5% (прогноз {growth:.2%}), стратегия: vega-scalping на колл-опционах QQQ (наибольшая vega, экспирация опционов от {(observe_date + timedelta(20-3)).strftime('%Y-%m-%d')} до {(observe_date + timedelta(20+3)).strftime('%Y-%m-%d')})\")\n",
    "        print('статистика стратегии: коэф. Шарпа (1.09), winrate (54%), ожидаемая доходность (47%), сделок (183), средняя vega (32.92)')\n",
    "    if qqq_forecast_data['rv_pred_t+20'][0] >= qqq_forecast_data['rv_t'][0] * 1.10:\n",
    "        growth = qqq_forecast_data['rv_pred_t+20'][0] / qqq_forecast_data['rv_t'][0] - 1\n",
    "        print(f\"20-дн рост RV по QQQ > 10% (прогноз {growth:.2%}), стратегия: vega-scalping на колл-опционах QQQ (наибольшая vega, экспирация опционов от {(observe_date + timedelta(20-3)).strftime('%Y-%m-%d')} до {(observe_date + timedelta(20+3)).strftime('%Y-%m-%d')})\")\n",
    "        print('статистика стратегии: коэф. Шарпа (0.83), winrate (52%), ожидаемая доходность (31%), сделок (133), средняя vega (33.37)')\n",
    "    if qqq_forecast_data['rv_pred_t+20'][0] >= qqq_forecast_data['rv_t'][0] * 1.15:\n",
    "        growth = qqq_forecast_data['rv_pred_t+20'][0] / qqq_forecast_data['rv_t'][0] - 1\n",
    "        print(f\"20-дн рост RV по QQQ > 15% (прогноз {growth:.2%}), стратегия: vega-scalping на колл-опционах QQQ (наибольшая vega, экспирация опционов от {(observe_date + timedelta(20-3)).strftime('%Y-%m-%d')} до {(observe_date + timedelta(20+3)).strftime('%Y-%m-%d')})\")\n",
    "        print('статистика стратегии: коэф. Шарпа (0.68), winrate (51%), ожидаемая доходность (26%), сделок (103), средняя vega (33.84)')\n",
    "    \n",
    "    print('\\ndelta-scalping:')\n",
    "    if qqq_forecast_data['rv_pred_t+5'][0] >= qqq_forecast_data['rv_t'][0] * 1.05:\n",
    "        growth = qqq_forecast_data['rv_pred_t+5'][0] / qqq_forecast_data['rv_t'][0] - 1\n",
    "        print(f\"5-дн рост RV по QQQ > 5% (прогноз {growth:.2%}), стратегия: delta-scalping на колл-опционах QQQ (наибольшая delta, экспирация опционов от {(observe_date + timedelta(5-3)).strftime('%Y-%m-%d')} до {(observe_date + timedelta(5+3)).strftime('%Y-%m-%d')})\")\n",
    "        print('статистика стратегии: коэф. Шарпа (2.20), winrate (64%), ожидаемая доходность (18%), сделок (112), средняя delta (0.91)')\n",
    "    if qqq_forecast_data['rv_pred_t+10'][0] >= qqq_forecast_data['rv_t'][0] * 1.05:\n",
    "        growth = qqq_forecast_data['rv_pred_t+10'][0] / qqq_forecast_data['rv_t'][0] - 1\n",
    "        print(f\"10-дн рост RV по QQQ > 5% (прогноз {growth:.2%}), стратегия: delta-scalping на колл-опционах QQQ (наибольшая delta, экспирация опционов от {(observe_date + timedelta(10-3)).strftime('%Y-%m-%d')} до {(observe_date + timedelta(10+3)).strftime('%Y-%m-%d')})\")\n",
    "        print('статистика стратегии: коэф. Шарпа (1.87), winrate (67%), ожидаемая доходность (23%), сделок (171), средняя delta (0.85)')\n",
    "    if qqq_forecast_data['rv_pred_t+15'][0] >= qqq_forecast_data['rv_t'][0] * 1.05:\n",
    "        growth = qqq_forecast_data['rv_pred_t+15'][0] / qqq_forecast_data['rv_t'][0] - 1\n",
    "        print(f\"15-дн рост RV по QQQ > 5% (прогноз {growth:.2%}), стратегия: delta-scalping на колл-опционах QQQ (наибольшая delta, экспирация опционов от {(observe_date + timedelta(15-3)).strftime('%Y-%m-%d')} до {(observe_date + timedelta(15+3)).strftime('%Y-%m-%d')})\")\n",
    "        print('статистика стратегии: коэф. Шарпа (1.33), winrate (66%), ожидаемая доходность (26%), сделок (200), средняя delta (0.8)')\n",
    "    if qqq_forecast_data['rv_pred_t+15'][0] >= qqq_forecast_data['rv_t'][0] * 1.1:\n",
    "        growth = qqq_forecast_data['rv_pred_t+15'][0] / qqq_forecast_data['rv_t'][0] - 1\n",
    "        print(f\"15-дн рост RV по QQQ > 10% (прогноз {growth:.2%}), стратегия: delta-scalping на колл-опционах QQQ (наибольшая delta, экспирация опционов от {(observe_date + timedelta(15-3)).strftime('%Y-%m-%d')} до {(observe_date + timedelta(15+3)).strftime('%Y-%m-%d')})\")\n",
    "        print('статистика стратегии: коэф. Шарпа (1.55), winrate (67%), ожидаемая доходность (29%), сделок (138), средняя delta (0.9)')\n",
    "    if qqq_forecast_data['rv_pred_t+20'][0] >= qqq_forecast_data['rv_t'][0] * 1.05:\n",
    "        growth = qqq_forecast_data['rv_pred_t+20'][0] / qqq_forecast_data['rv_t'][0] - 1\n",
    "        print(f\"20-дн рост RV по QQQ > 5% (прогноз {growth:.2%}), стратегия: delta-scalping на колл-опционах QQQ (наибольшая delta, экспирация опционов от {(observe_date + timedelta(20-3)).strftime('%Y-%m-%d')} до {(observe_date + timedelta(20+3)).strftime('%Y-%m-%d')})\")\n",
    "        print('статистика стратегии: коэф. Шарпа (1.39), winrate (63%), ожидаемая доходность (35%), сделок (174), средняя delta (0.77)')\n",
    "    if qqq_forecast_data['rv_pred_t+20'][0] >= qqq_forecast_data['rv_t'][0] * 1.1:\n",
    "        growth = qqq_forecast_data['rv_pred_t+20'][0] / qqq_forecast_data['rv_t'][0] - 1\n",
    "        print(f\"20-дн рост RV по QQQ > 10% (прогноз {growth:.2%}), стратегия: delta-scalping на колл-опционах QQQ (наибольшая delta, экспирация опционов от {(observe_date + timedelta(20-3)).strftime('%Y-%m-%d')} до {(observe_date + timedelta(20+3)).strftime('%Y-%m-%d')})\")\n",
    "        print('статистика стратегии: коэф. Шарпа (1.30), winrate (65%), ожидаемая доходность (31%), сделок (128), средняя delta (0.78)')\n",
    "    \n",
    "    print('\\nstraddle:')\n",
    "    if qqq_forecast_data['rv_pred_t+5'][0] <= qqq_forecast_data['rv_t'][0] * 0.9:\n",
    "        growth = qqq_forecast_data['rv_pred_t+5'][0] / qqq_forecast_data['rv_t'][0] - 1\n",
    "        print(f\"5-дн падение RV по QQQ > 10% (прогноз {growth:.2%}), стратегия: straddle на опционах QQQ (самые дальние от страйка колл- и пут-опционы, экспирация опционов от {(observe_date + timedelta(5-3)).strftime('%Y-%m-%d')} до {(observe_date + timedelta(5+3)).strftime('%Y-%m-%d')})\")\n",
    "        print('статистика стратегии: коэф. Шарпа (0.37), winrate (51%), ожидаемая доходность (3%), сделок (102)')\n",
    "    if qqq_forecast_data['rv_pred_t+10'][0] <= qqq_forecast_data['rv_t'][0] * 0.9:\n",
    "        growth = qqq_forecast_data['rv_pred_t+10'][0] / qqq_forecast_data['rv_t'][0] - 1\n",
    "        print(f\"10-дн падение RV по QQQ > 10% (прогноз {growth:.2%}), стратегия: straddle на опционах QQQ (самые дальние от страйка колл- и пут-опционы, экспирация опционов от {(observe_date + timedelta(10-3)).strftime('%Y-%m-%d')} до {(observe_date + timedelta(10+3)).strftime('%Y-%m-%d')})\")\n",
    "        print('статистика стратегии: коэф. Шарпа (0.37), winrate (50%), ожидаемая доходность (5%), сделок (224)')\n",
    "    if qqq_forecast_data['rv_pred_t+10'][0] <= qqq_forecast_data['rv_t'][0] * 0.95:\n",
    "        growth = qqq_forecast_data['rv_pred_t+10'][0] / qqq_forecast_data['rv_t'][0] - 1\n",
    "        print(f\"10-дн падение RV по QQQ > 5% (прогноз {growth:.2%}), стратегия: straddle на опционах QQQ (ближайшие к страйку колл- и пут-опционы, экспирация опционов от {(observe_date + timedelta(10-3)).strftime('%Y-%m-%d')} до {(observe_date + timedelta(10+3)).strftime('%Y-%m-%d')})\")\n",
    "        print('статистика стратегии: коэф. Шарпа (0.26), winrate (48%), ожидаемая доходность (3%), сделок (400)')\n",
    "    if qqq_forecast_data['rv_pred_t+10'][0] <= qqq_forecast_data['rv_t'][0] * 0.9:\n",
    "        growth = qqq_forecast_data['rv_pred_t+10'][0] / qqq_forecast_data['rv_t'][0] - 1\n",
    "        print(f\"10-дн падение RV по QQQ > 10% (прогноз {growth:.2%}), стратегия: straddle на опционах QQQ (ближайшие к страйку колл- и пут-опционы, экспирация опционов от {(observe_date + timedelta(10-3)).strftime('%Y-%m-%d')} до {(observe_date + timedelta(10+3)).strftime('%Y-%m-%d')})\")\n",
    "        print('статистика стратегии: коэф. Шарпа (0.33), winrate (48%), ожидаемая доходность (4%), сделок (224)')"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.12.3"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
